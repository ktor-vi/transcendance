// üéÆ SERVEUR DE JEU AVEC ATTENTE DE 2 JOUEURS
import crypto from "crypto";
import fp from "fastify-plugin";

const FIELD_WIDTH = 13.5;
const FIELD_DEPTH = 7.5;
const PDL_SPD = 0.25;
const MAX_SCORE = 11;

function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value));
}

export default fp(async function (fastify) {
  const rooms = new Map();

  function createRoom(forcedId = null) {
    const roomId = forcedId || crypto.randomUUID().slice(0, 8);

    // Nettoyer l'ancienne room si elle existe
    if (rooms.has(roomId)) {
      const oldRoom = rooms.get(roomId);
      if (oldRoom.loop) {
        clearInterval(oldRoom.loop);
      }
      rooms.delete(roomId);
      console.log(`üßπ Ancienne room ${roomId} nettoy√©e`);
    }

    console.log(`üéÆ Cr√©ation de la room: ${roomId}`);

    // √âtat initial du jeu
    const gameState = {
      ball: { x: 0, z: 0, dx: 0.05, dz: 0.1 },
      paddleOne: { x: 0 },
      paddleTwo: { x: 0 },
      score: { p1: 0, p2: 0 },
      gameEnded: false,
      winner: null,
      players: new Map(), // playerNumber -> playerName
      playersReady: 0, // Compteur de joueurs connect√©s
      gameActive: false, // Jeu actif ou en attente
    };

    // Cr√©er la room
    const room = {
      gameState,
      roomId,
      lastUpdateTime: Date.now(),
      loop: null, // Pas de boucle au d√©but
    };

    rooms.set(roomId, room);
    console.log(`‚úÖ Room ${roomId} cr√©√©e - en attente de joueurs`);

    return roomId;
  }

  // üîß NOUVELLE FONCTION: D√©marrer la boucle de jeu
  function startGameLoop(roomId) {
    const room = rooms.get(roomId);
    if (!room) {
      console.warn(`‚ö†Ô∏è Impossible de d√©marrer - room ${roomId} inexistante`);
      return;
    }

    if (room.loop) {
      console.log(`‚ö†Ô∏è Boucle de jeu d√©j√† active pour ${roomId}`);
      return;
    }

    console.log(`üöÄ D√©marrage de la boucle de jeu pour ${roomId}`);
    room.gameState.gameActive = true;

    // D√©marrer la boucle de jeu √† 60 FPS
    room.loop = setInterval(() => updateRoom(roomId), 1000 / 60);
  }

  // üîß NOUVELLE FONCTION: Arr√™ter la boucle de jeu
  function stopGameLoop(roomId) {
    const room = rooms.get(roomId);
    if (!room) return;

    if (room.loop) {
      clearInterval(room.loop);
      room.loop = null;
      room.gameState.gameActive = false;
      console.log(`‚èπÔ∏è Boucle de jeu arr√™t√©e pour ${roomId}`);
    }
  }

  function updateRoom(roomId) {
    const room = rooms.get(roomId);
    if (!room) {
      console.warn(
        `‚ö†Ô∏è Tentative de mise √† jour d'une room inexistante: ${roomId}`
      );
      return;
    }

    const gs = room.gameState;

    // üîß NOUVEAU: Ne pas mettre √† jour si le jeu n'est pas actif
    if (!gs.gameActive || gs.gameEnded) {
      return;
    }

    // üîß NOUVEAU: V√©rifier qu'il y a bien 2 joueurs
    if (gs.playersReady < 2) {
      return;
    }

    // Physique de la balle
    gs.ball.x += gs.ball.dx;
    gs.ball.z += gs.ball.dz;

    // Contraindre les paddles dans les limites du terrain
    gs.paddleOne.x = clamp(
      gs.paddleOne.x,
      -FIELD_WIDTH / 2 + 1,
      FIELD_WIDTH / 2 - 1
    );
    gs.paddleTwo.x = clamp(
      gs.paddleTwo.x,
      -FIELD_WIDTH / 2 + 1,
      FIELD_WIDTH / 2 - 1
    );

    // Rebonds sur les murs lat√©raux
    if (gs.ball.x <= -FIELD_WIDTH / 2 || gs.ball.x >= FIELD_WIDTH / 2) {
      gs.ball.dx *= -1;
    }

    // Collision avec le paddle du joueur 1 (c√¥t√© n√©gatif Z)
    if (
      gs.ball.z <= -FIELD_DEPTH / 2 + 0.5 &&
      gs.ball.z >= -FIELD_DEPTH / 2 - 0.5 &&
      Math.abs(gs.ball.x - gs.paddleOne.x) < 1.1
    ) {
      gs.ball.z = -FIELD_DEPTH / 2 + 0.5;
      gs.ball.dz = Math.abs(gs.ball.dz); // Renvoie vers le positif
    }

    // Collision avec le paddle du joueur 2 (c√¥t√© positif Z)
    if (
      gs.ball.z >= FIELD_DEPTH / 2 - 0.5 &&
      gs.ball.z <= FIELD_DEPTH / 2 + 0.5 &&
      Math.abs(gs.ball.x - gs.paddleTwo.x) < 1.1
    ) {
      gs.ball.z = FIELD_DEPTH / 2 - 0.5;
      gs.ball.dz = -Math.abs(gs.ball.dz); // Renvoie vers le n√©gatif
    }

    // Gestion des points
    let pointScored = false;
    let scoringPlayer = null;

    if (gs.ball.z <= -FIELD_DEPTH / 2 - 0.5) {
      // La balle sort c√¥t√© joueur 1 ‚Üí Joueur 2 marque
      gs.score.p2++;
      scoringPlayer = 2;
      pointScored = true;
      console.log(`üéØ Point pour P2! Score: ${gs.score.p1}-${gs.score.p2}`);
    } else if (gs.ball.z >= FIELD_DEPTH / 2 + 0.5) {
      // La balle sort c√¥t√© joueur 2 ‚Üí Joueur 1 marque
      gs.score.p1++;
      scoringPlayer = 1;
      pointScored = true;
      console.log(`üéØ Point pour P1! Score: ${gs.score.p1}-${gs.score.p2}`);
    }

    if (pointScored) {
      // R√©initialiser la position de la balle
      gs.ball.x = 0;
      gs.ball.z = 0;
      gs.ball.dx = (Math.random() - 0.5) * 0.1; // Direction horizontale al√©atoire
      gs.ball.dz = scoringPlayer === 1 ? 0.1 : -0.1; // Direction vers l'adversaire

      // Informer le syst√®me de tournoi (si applicable)
      if (fastify.updateMatchScore) {
        const player1Name = gs.players.get(1) || "Player1";
        const player2Name = gs.players.get(2) || "Player2";

        fastify.updateMatchScore(
          roomId,
          player1Name,
          player2Name,
          gs.score.p1,
          gs.score.p2
        );
      }

      // V√©rifier la condition de fin de partie
      if (gs.score.p1 >= MAX_SCORE || gs.score.p2 >= MAX_SCORE) {
        endGame(room, scoringPlayer);
        return; // Sortir pour √©viter de diffuser apr√®s la fin
      }
    }

    // Diffuser l'√©tat du jeu via le gestionnaire WebSocket unifi√©
    if (fastify.broadcastToGameRoom) {
      fastify.broadcastToGameRoom(roomId, {
        type: "state",
        gameState: {
          ball: { ...gs.ball },
          paddleOne: { ...gs.paddleOne },
          paddleTwo: { ...gs.paddleTwo },
          scoreP1: gs.score.p1,
          scoreP2: gs.score.p2,
          gameEnded: gs.gameEnded,
          gameActive: gs.gameActive,
        },
      });
    }
  }

  function endGame(room, winningPlayerNumber) {
    const gs = room.gameState;

    // Marquer le jeu comme termin√©
    gs.gameEnded = true;
    gs.gameActive = false;
    gs.winner = winningPlayerNumber;

    // R√©cup√©rer les noms des joueurs
    const winnerName =
      gs.players.get(winningPlayerNumber) || `Player${winningPlayerNumber}`;
    const loserNumber = winningPlayerNumber === 1 ? 2 : 1;
    const loserName = gs.players.get(loserNumber) || `Player${loserNumber}`;

    console.log(
      `üèÅ Fin de partie ${room.roomId}: ${winnerName} bat ${loserName} ${gs.score.p1}-${gs.score.p2}`
    );

    // Informer le syst√®me de tournoi du r√©sultat final (si applicable)
    // if (fastify.updateMatchScore) {
    //   const player1Name = gs.players.get(1) || "Player1";
    //   const player2Name = gs.players.get(2) || "Player2";

    //   fastify.updateMatchScore(
    //     room.roomId,
    //     player1Name,
    //     player2Name,
    //     gs.score.p1,
    //     gs.score.p2,
    //     winnerName
    //   );
    // }

    // Diffuser la fin de partie
    if (fastify.broadcastToGameRoom) {
      fastify.broadcastToGameRoom(room.roomId, {
        type: "gameEnd",
        winner: winnerName,
        loser: loserName,
        scoreP1: gs.score.p1,
        scoreP2: gs.score.p2,
        winnerNumber: winningPlayerNumber,
      });
    }

    // Arr√™ter la boucle de mise √† jour
    stopGameLoop(room.roomId);

    // Programmer la suppression de la room
    setTimeout(() => {
      rooms.delete(room.roomId);
      console.log(`üóëÔ∏è Room ${room.roomId} supprim√©e apr√®s fin de partie`);
    }, 5000);
  }

  function ensureRoom(roomId, player1Name, player2Name) {
    // Cr√©er la room si elle n'existe pas
    if (!rooms.has(roomId)) {
      createRoom(roomId);
    }

    const room = rooms.get(roomId);

    // üîß MODIFICATION: Configurer les joueurs et d√©marrer si 2 joueurs
    if (player1Name) {
      room.gameState.players.set(1, player1Name);
    }
    if (player2Name) {
      room.gameState.players.set(2, player2Name);
    }

    // üîß NOUVEAU: Compter les joueurs connect√©s
    room.gameState.playersReady = room.gameState.players.size;

    console.log(
      `üéÆ Room ${roomId} configur√©e: ${player1Name || "Player1"} vs ${
        player2Name || "Player2"
      } (${room.gameState.playersReady}/2 joueurs)`
    );

    // üîß NOUVEAU: D√©marrer le jeu si 2 joueurs sont pr√™ts
    if (room.gameState.playersReady >= 2 && !room.loop) {
      console.log(`üöÄ 2 joueurs connect√©s - d√©marrage du jeu ${roomId}`);
      startGameLoop(roomId);
    }

    return room;
  }

  // üîß MODIFICATION: G√©rer la connexion/d√©connexion des joueurs
  function handlePlayerConnection(roomId, playerNumber, playerName) {
    const room = rooms.get(roomId);
    if (!room) {
      console.warn(`‚ö†Ô∏è Room ${roomId} non trouv√©e pour connexion joueur`);
      return false;
    }

    // Ajouter le joueur
    room.gameState.players.set(playerNumber, playerName);
    room.gameState.playersReady = room.gameState.players.size;

    console.log(
      `üëã Joueur ${playerNumber} (${playerName}) connect√© √† ${roomId} (${room.gameState.playersReady}/2)`
    );

    // D√©marrer le jeu si 2 joueurs sont connect√©s
    if (room.gameState.playersReady >= 2 && !room.loop) {
      console.log(`üöÄ 2 joueurs connect√©s - d√©marrage du jeu ${roomId}`);
      setTimeout(() => startGameLoop(roomId), 1000); // Petit d√©lai pour que les clients soient pr√™ts
    }

    return true;
  }

  function handlePlayerDisconnection(roomId, playerNumber) {
    const room = rooms.get(roomId);
    if (!room) return;

    // Retirer le joueur
    room.gameState.players.delete(playerNumber);
    room.gameState.playersReady = room.gameState.players.size;

    console.log(
      `üëã Joueur ${playerNumber} d√©connect√© de ${roomId} (${room.gameState.playersReady}/2)`
    );

    // Arr√™ter le jeu si moins de 2 joueurs
    if (room.gameState.playersReady < 2) {
      console.log(`‚èπÔ∏è Moins de 2 joueurs - arr√™t du jeu ${roomId}`);
      stopGameLoop(roomId);
    }
  }

  function handleGameInput(roomId, playerNumber, inputMsg) {
    const room = rooms.get(roomId);

    if (!room) {
      console.warn(`‚ö†Ô∏è Input ignor√©: room ${roomId} inexistante`);
      return;
    }

    // üîß NOUVEAU: Ignorer les inputs si le jeu n'est pas actif
    if (!room.gameState.gameActive || room.gameState.gameEnded) {
      return;
    }

    // üîß NOUVEAU: Ignorer si pas assez de joueurs
    if (room.gameState.playersReady < 2) {
      return;
    }

    const actualPlayerNumber = inputMsg.playerNumber || playerNumber;

    if (actualPlayerNumber !== 1 && actualPlayerNumber !== 2) {
      console.warn(`‚ö†Ô∏è Num√©ro de joueur invalide: ${actualPlayerNumber}`);
      return;
    }

    const paddle =
      actualPlayerNumber === 1
        ? room.gameState.paddleOne
        : room.gameState.paddleTwo;

    const PADDLE_SPEED = 0.3; // Augment√© pour plus de r√©activit√©



    // Appliquer le mouvement
    if (inputMsg.left) {
      paddle.x = Math.max(paddle.x - PADDLE_SPEED, -FIELD_WIDTH / 2 + 1);
    }
    if (inputMsg.right) {
      paddle.x = Math.min(paddle.x + PADDLE_SPEED, FIELD_WIDTH / 2 - 1);
    }
  }

  function getAllRoomsStatus() {
    const roomList = [];

    for (const [roomId, room] of rooms.entries()) {
      roomList.push({
        roomId,
        score: { ...room.gameState.score },
        gameEnded: room.gameState.gameEnded,
        gameActive: room.gameState.gameActive,
        playersReady: room.gameState.playersReady,
        winner: room.gameState.winner,
        players: Object.fromEntries(room.gameState.players),
        lastUpdate: room.lastUpdateTime,
      });
    }

    return roomList;
  }

  // üîß NOUVELLE FONCTION: Obtenir le statut d'une room sp√©cifique
  function getRoomStatus(roomId) {
    const room = rooms.get(roomId);
    if (!room) {
      return null;
    }

    return {
      roomId,
      gameState: {
        ball: { ...room.gameState.ball },
        paddleOne: { ...room.gameState.paddleOne },
        paddleTwo: { ...room.gameState.paddleTwo },
        score: { ...room.gameState.score },
        gameEnded: room.gameState.gameEnded,
        gameActive: room.gameState.gameActive,
        playersReady: room.gameState.playersReady,
        winner: room.gameState.winner,
      },
      players: Object.fromEntries(room.gameState.players),
      lastUpdate: room.lastUpdateTime,
    };
  }

  // ===== EXPOSER LES FONCTIONS PUBLIQUES =====

  fastify.decorate("createRoom", createRoom);
  fastify.decorate("ensureRoom", ensureRoom);
  fastify.decorate("handleGameInput", handleGameInput);
  fastify.decorate("getRoomStatus", getRoomStatus);
  fastify.decorate("getAllRoomsStatus", getAllRoomsStatus);
  fastify.decorate("handlePlayerConnection", handlePlayerConnection);
  fastify.decorate("handlePlayerDisconnection", handlePlayerDisconnection);

  // ===== NETTOYAGE √Ä L'ARR√äT =====

  fastify.addHook("onClose", async () => {
    console.log("üßπ Nettoyage des rooms de jeu...");

    for (const [roomId, room] of rooms.entries()) {
      if (room.loop) {
        clearInterval(room.loop);
      }
    }

    rooms.clear();
    console.log("‚úÖ Serveur de jeu nettoy√©");
  });

  console.log("üéÆ Serveur de jeu initialis√© avec attente de 2 joueurs");
});
